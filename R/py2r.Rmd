---
title: "py2r"
author: "Contentio d.o.o."
date: '26 11 2020 '
output: html_document
---

```{r setup}
library(data.table)
library(xts)
library(quantmod)
library(fmlr)
library(tseries)
library(data.table)
library(reticulate)
library(here)
library(future.apply)
source(here("R", "import_data.R"))
source(here("R", "features.R"))
source(here("R", "outliers.R"))
source(here("R", "parallel_functions.R"))
source(here("R", "execution.R"))
py <- reticulate::use_python('C:/ProgramData/Anaconda3')
```


```{python}
import pandas as pd
import mlfinlab as ml
```


```{r}
# Import
market_data <- import_mysql(
  contract = 'SPY5',
  save_path = 'D:/market_data/usa/ohlcv',
  trading_days = TRUE,
  upsample = FALSE,
  RMySQL::MySQL(),
  dbname = 'odvjet12_market_data_usa',
  username = 'odvjet12_mislav',
  password = 'Theanswer0207',
  host = '91.234.46.219'
)
```


```{r}
# Remove outliers
market_data <- remove_outlier_median(market_data, median_scaler = 25)

# Add features
market_data <- add_features(market_data)

# Remove constant columns (from https://stackoverflow.com/questions/15068981/removal-of-constant-columns-in-r)
market_data <- market_data[,!apply(market_data, MARGIN = 2, function(x) max(x, na.rm = TRUE) == min(x, na.rm = TRUE))]
```


```{r}
market_data_sample <- market_data[1:100000, ]
market_data_sample <- as.data.table(market_data_sample)
t_events <- sample(market_data_sample$index, 50000)
head(market_data_sample)
```


```{r}
t_events = t_events
close = market_data_sample$close
num_days = 1
num_hours = 0
num_minutes = 0
num_seconds = 0

# order events
t0 <- t_events[order(t_events)]

# turn numeric to timedelta
num_days <- lubridate::days(num_days)
num_hours <- lubridate::hours(num_hours)
num_minutes <- lubridate::minutes(num_minutes)
num_seconds <- lubridate::seconds(num_seconds)

# define timedelta
t1 <- t0 + num_days + num_hours + num_minutes + num_seconds

# Find index to closest to vertical barrier
t1 <- as.data.table(cbind(t1, TRUE))
colnames(t1) <- c('index', 'test')
close_ <- as.data.table(close)
nearest_index <- t1[close_, roll = 'nearest', on = 'index']
head(nearest_index)
nrow(nearest_index)
head(t1)
```


```{r}
vertical_barriers_r <- function(t_events, close, num_days, num_hours, num_minutes, num_seconds) {
  # order events
  t0 <- t_events[order(t_events)]
  
  # turn numeric to timedelta
  num_days <- lubridate::days(num_days)
  num_hours <- lubridate::hours(num_hours)
  num_minutes <- lubridate::minutes(num_minutes)
  num_seconds <- lubridate::seconds(num_seconds)
  
  # define timedelta
  t1 <- t0 + num_days + num_hours + num_minutes + num_seconds
  
  # Find index to closest to vertical barrier
  nearest_index <- vapply(t1, function(x) which.min(abs(x - zoo::index(close))), numeric(1))
  
  # Exclude indexes which are outside the range of close price index
  nearest_index = nearest_index[nearest_index < length(close)]
  
  # Find price index closest to vertical barrier time stamp
  nearest_timestamp = close[nearest_index]
  filtered_events = t0[1:length(nearest_index)]
  
  # convert to data frime
  vertical_barriers = cbind.data.frame(t0 = filtered_events, t1 = zoo::index(nearest_timestamp))
  return(vertical_barriers)
}
```



```{python}
# Convert R objects to python objects
data_py = pd.DataFrame(r.market_data_sample)
data_py.index = r.market_data_sample['index']
data_py = data_py.drop(columns=['index'])
t_events_py = r.t_events
t_events_py[:5]

# Compute vertical barrier
vertical_barriers = ml.labeling.add_vertical_barrier(t_events=t_events_py, close=data_py.close, num_days=1)
```

```{python}
vertical_barriers.head()
```


```{r}

```

